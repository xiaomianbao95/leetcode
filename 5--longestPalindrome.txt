给定一个字符串 s，找到 s 中最长的回文子串。你可以假设?s 的最大长度为 1000。




示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"



分析：回文串就是一个字符串正向读和反向读结果一样。
 
第一种方法：中心扩展法，因为回文串以中心对称，所以我们可以从中心向两边比较看字符串最大能到达的地方但是要考虑奇数
和偶数的情况，所以我们分两种情况1)从一个中心点往两边扩展，这样得到的最长回文串一定是奇数长度的；2）以中心两个点往
两边扩展，这样得到的最长回文串一定是偶数长度的，最后比较这两个的长度，选择出最大的，注意最后while循环退出的时候
left已经减1，right已经加1了，但是我们需要的是left和right位置之间的，所以最后截取时，left+1，因为substring()方法包前不
包后，所以substring(left+1,right)可以得到需要的字符串。
class Solution {
    public String longestPalindrome(String s) {
        if(s==null||s.length()==0)
            return "";
        int maxlongest=0;
        String maxlongestPalind=s.substring(0,1);
        for(int i=0;i<s.length();i++){
            String maxodd=longestPalindrome2(s,i,i);
            String maxeven=longestPalindrome2(s,i,i+1);
             String maxlen=maxodd.length()>maxeven.length()?maxodd:maxeven;
            if(maxlen.length()>maxlongest){
                maxlongestPalind=maxlen;
                maxlongest=maxlen.length();
            }
        }
        return maxlongestPalind;
        
    }
    public String longestPalindrome2(String s,int left,int right){
        while(left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }
        return s.substring(left+1,right);
    }
}
